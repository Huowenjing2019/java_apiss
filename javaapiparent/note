包的命明规则：
企业域名的反写+项目名称+模块名称
   com.alibaba.double.bio
 ---------------------------------------------------------------
1、方法的定义：
   *完成某一个具体功能的代码块，从某种程度上来说，
    可以使代码得到很好的复用。
   *方法的修饰符   返回值类型   方法名（参数表）
   *public static 返回值类型  方法名（参数表）{
//方法的实现
}
//求1到100的和
public class Oop1 {
    public static void myself(int n) {
        int sum = 0;
        for (int i = 0; i <= 100; i++) {
            sum += i;
        }
        System.out.println(sum);
    }

    //调用方法：
    public static void main(String[] args) {
        myself(100);
    }
----------------------------------------------------------------
2、返回值类型的种类：
    基本数据类型
    引用数据类型
    void数据类型
----------------------------------------------------------------
3、方法名：遵循一般变量的命名规则
    参数表：每一个参数必须有类型。多个参数之间必须使用“，”隔开
    方法体：使用两个{{}}表示，方法的具体业务实现，写在花括号里
            方法体写完后，根据返回值类型来确定返回什么样的值

public static int min(int[] args){
    int tmp=[args[0]];//将args数组的第一个位置的元素名为最小值tmp
    for(int i=1;i<args.length;i++){
        if(tmp<args[i]{
            tmp=args[i];
        }
    }
    return tmp;
}

写一个方法拼接两个数组形成一个新数组
编写一个方法函数随机打印出5个不同的A-Z中的五个字符而且不能重复


----------------------------------------------------------------
3、数组：同一种相同数据类型的元素的集合。具有线型结构
   声明方式：数据类型 []数组名词=new 数据类型长度；
         *int [] arr=new int[6];
         *int [] arr={1,5,8,9}
   访问数组：通过下标访问数组
   为数组赋值：arr[1]=1
   length；属性
   遍历数组：（for循环 ）

----------------------------------------------------------------
4、随机数的产生：Random r=new Random();
                int i=r.nextInt(26);
 ---------------------------------------------------------------
5、方法调用：
    方法写好就可以调用，实参初始化形参的方法调用过程
    非静态方法要用对象去调用。
  --------------------------------------------------------------
6、面向对象：面向对象是软件开发方法。
    类：类是一系列相同对象的属性和行为的抽象。是一个模板。
        是一种抽象的东西，现实生活中不存在，封装了一系列
        对象的属性和行为
    对象：现实生活中一切万物皆对象。每个对象都有其所属的类。
         要做到看到对象联想的该类对象所属的类，这个过程叫做抽类
    面向对象的三大特征：
    a、封装
        就是把一系列对象所具有的共同的属性和行为进行抽取出来，
        形成一个类，通过这个类封装了这些对象所具有的属性和行为
    b、继承
    c、多态
  --------------------------------------------------------------
7、java的类结构
    public class 类名{
    //若干属性（成员变量）
    //若干行为（方法）
    }
    属性：是说明某一个对象的某一个特征的专有名词【成员变量】
    行为：描述的是对象的某一个动作（动词）【方法】

    人类：
    类名：person
    属性：姓名 权限修饰符（public）数据类型（string）变量名（name）
          性别 权限修饰符（public）数据类型（char）变量名（gender）
          年龄 权限修饰符（public）数据类型（int）变量名（age）
          身高 权限修饰符（public）数据类型（double）变量名（height）
          体重 权限修饰符（public）数据类型（double）变量名（weight）
    行为：void是没有返回值
          吃饭:
方法的权限修饰符（public）返回值类型（void）方法名eat 参数表（无参数）
          睡觉:
方法的权限修饰符（public）返回值类型（void）方法名sleep 参数表（无参数）
          喝水:
方法的权限修饰符（public）返回值类型（int）方法名sum 参数表（int a,int b）
 --------------------------------------------------------------
 8、类一旦创建成功，就可以通过该类创建该类的实例（对象），
    一旦对象创建成功那么该对象就可以为所欲为
 ---------------------------------------------------------------
 9、创建对象的合适
    类名  对象的引用名=new 类名（）；

    通过对象访问对象的属性和行为，java语言里面采用
    对象名.属性名  或者对象名.方法名（）；

  注意：如果创建一个类的时候没有为类的成员变量赋值，那么
        JAVA程序会为每一种数据类型的变量初始化值。引用类型初始化
        为null,整形初始化为0，浮点型初始化为0.0，boolean初始化为
        false，char初始化为''
-------------------------------------------------------------------


2019-11-13笔记
创建对象的实现原理：
java程序底层是调用了类提供方的构造器（构造方法）来完成对象的初始化和创建


1、构造器：
    作用：完成对象初始化和创建，初始化时完成对象的属性

         （ 通过new关键字调用类提供的构造器完成对象的初始化和创建）
    特点：修饰符类型一般是public
          没有返回值类型
          方法名称必须和类名完全一样
    注意：如果创建类的时候没有为类显示指定的构造器，那么java程序会默认
          创建一个无参数的构造器。
          如一旦开发人员显示指定有参数的构造器以后，那么无参数的构造器就会
          失效，这时必须显示声明无参数的构造器，否则编译失败。方法名相同，
          参数不同就是方法的重载

this关键字：区分一个变量是否是一个类的实例属性
          使用在两个地方：
          1、普通实例方法里
            表示调用该普通实例方法的当前对象，也就是说，哪个对象调用的方法
            那么该方法里面出现this就表示那个对象（注意：this表示对象，每一个
            普通方法都有一个隐含的this。里都有一个this，this.在普通方法里可以
            省略，静态方法不使用
            ）
          2、构造器里面
            a、表示利用构造器即将创建的对象
            b、表示当前类的其他构造器。this只能放第一行

  getter 与setter方法：
  有时候如果一个字段被private修饰那么该字段不可以被外界直接访问
  如果要访问必须使用getter方法，如果修改值，必须使用setter方法
    格式  ：get属性名称  set属性名称
    没有stack的方法都是实例方法


  -----------------------------------------------------------------------
  对象数组：
  数据类型  [] 数组名=new 数据类型[长度]；
  int []  arrs=new int[10];
  Person []ps=new Person[10];//引用数据类型 初始值都为null
  -----------------------------------------------------------------------
  继承的好处：
  1、重写父类方法
  2、扩展子类的独有的方法或者属性
  3、可以使得代码得到良好的复用
  特点：
    重写基类的方法，扩展子类
    补充：封装会满足has a 的关系 继承满足is a的关系

  A继承B  A  extends  B

  tip：如果一个属性或者一个方法被proteced修饰，那么该属性一定可以
       被子类继承，private修饰的不能被子类继承
--------------------------------------------------------------

2019.11.20   周三早晨
1、重写的规则：
满足：两同，两小，一大
两同：
    子类重写父类的方法名和参数列表必须和父类方法名和参数
    列表必须完全一样
两小：
    子类的返回值类型必须小于或等于父类的方法的返回值类型，
    子类方法抛出的异常类型一样必须小于或者等于父类方法抛出的
    异常类型
一大：
    子类方法的权限修饰符的权限必须大于或等于父类方法的修饰符
    权限

 2、super关键字
 1）在使用子类实例方法中，可以使用super.方法名的形式
    调用父类方法
 2）是在构造器里面，表示调用父类的构造器初始化当前创建的对象

 3、权限修饰符
 ------------------------------------------------------
    修饰符       本类        同包类      子类     其他
    public       能          能           能       能
    protected    能          能           能       不能
    默认修饰符    能          能          不能     不能
    private      能          不能         不能     不能
  ---------------------------------------------------------
 4、包：区分两个同名的类
    命名方式：
            企业域名+项目名+模块名称
            com.alibaba.double.rpc

    导包：
    使用import关键字导包：import 包名.类名
                         import 包名.*
                         使用包的全路径

 5、多态：一种事物的多种表现形式叫做多态，java语言里面把一个类
          拥有不同的子类叫做这个类的多态

 6、抽象类
    抽象类是一个半成品，该类必须进一步加工才能使用

    java语言抽象：
        抽象类使用abstract关键字修饰，抽象类里面可以含有抽象方法也有
        实例方法，类方法，成员变量等

    格式：public abstract class  类名{
        //若干成员变量
        //若干方法
        //若干抽象方法
    }

    抽象方法：方法的修饰符必须加上abstract，并且抽象方法没有方法体
    比如：
    public abstract void m();

    局部变量
          把在方法参数列表，方法体里面定义的变量都是
          局部变量，局部变量的生命周期随着方法调用的结束而结束
    全局变量：非局部变量的就是全局变量

    final关键字：
    1）被final关键字修改的不能被子类继承
    2）被final修饰的方法不能被子类重写
    3）被final修饰的变量不能被再次赋值

    补充：函数的可变形参
    数据类型 ... 参数名称
    public static void m4(int a,int...c){
        System.out.println(c.length);
    }

   常量
     Java语言里面的常量标准写法：
     public static final 数据类型  常量名="常量值"
     public static final String DESC="xxx";

 7、接口:接口是一个公共标准，一个约束
    java里面的接口，使用关键字 interface修饰
格式：
    public interface 接口名称{
    //若干抽象方法
    //常量
    }
  注意：JDK1.8之前，接口里面只能有抽象方法和常量
  类实现接口使用

 8、 抽象类普通类的区别：
  相同点：都可以含有普通属性和方法
  不同点：
        抽象类必须使用abstract修饰，抽象类可以含有抽象方法
        抽象类不可以实例化，就是不能创建实例对象。

  抽象方法与实例方法的区别：
  相同点：
        都有权限修饰符  返回值类型  参数列表
  不同点：
        抽象方法必须使用abstract关键字修饰，且没有方法体，并且
        只出现抽象类的接口中。

  -----------------------------------------------------------
  9、内部类：
静态内部类：
  外部类类名.静态内部类类名 对象引用名称=new 静态内部类构造器
非静态内部类：
  创建外部类对象 对象引用名称=外部类对象.new 非静态内部类的构造器
  注意：非静态内部类不能含有静态资源。
匿名内部类：
  就是没有类名的类，匿名内部类一定是某一个类，或者抽象，接口的子类。
  假设一个类只需要使用一次，那么就可以使用匿名内部类。

  10、函数式接口：
  接口里面只有一个抽象方法的接口叫做函数式接口，这是JDK1.8以上版本
  支持的，而且可在接口智商使用@FunctionInterface注解修饰
  一个接口，表示该接口是一个函数式接口，函数式接口支持lambda表达式
  创建接口子类实例。除此以外JDK1.8还新增加了接口约定。

  lambda表达式的书写规则：
  先写参数列表
  写-->
  写方法体
  ---------------------------------------------------------------
  2019/11/23 周六
                        工程化专题
1、块：
静态代码块：
  static{
    //语句块
  }
  //用于初始化静态资源（图片、音频）

普通代码块：
    //不常用，对象创建一次，普通代码块就执行一次

public class 类名{
    //静态代码块
    //普通代码块
    //静态方法
    //普通实例方法
    //属性
}

讨论：静态代码块、普通代码块、构造器的执行流程
如果只有一个类的时候，静态的先执行，然后普通代码块，最后执行构造器
静态的只执行一次。两个类有继承关系，先执行父类的静态代码块、子类的
静态代码块，父类的普通代码块、子类的普通代码块，最后执行父类的构造器
子类的构造器。

2、Maven:
    管理依赖、管理项目的

  安装Maven
  Apache官网下载Maven
  安装Maven

  配置中央仓库

  配置Maven环境变量
  电脑--->属性--->环境变量--->系统环境变量
3、Idea项目集成Maven
pom文件

MAVEN工程的项目类型主要有三种：（打包方式）
*pom工程  pom文件是核心文件千万不能删掉（聚合工程）
    管理所有的子工程，比如对子工程的jar包版本依赖管理，插件管理等
    pom工程不需要src目录
*jar工程（默认的）
    maven只会打包所有的.java文件不会打包配置文件
*war工程
    会打包所有的文件，包括配置文件.标准的wed配置。
可以使用packeging节点进行打包 打包方式如下：
<packagin>pom</packaging>
<packagin>jar</packaging>
<packagin>war</packaging>

4、约定优于配置，配置优于编码
<properties>
    <project.build.sourceEncoding>UTF-8</project.build.sourceEncoding>
    <maven.compiler.source>1.8</maven.compiler.source>
    <maven.compiler.target>1.8</maven.compiler.target>
  </properties>
可以自定义节点名称来控制依赖的版本号

5、dependency节点：
该节点下有许多的dependency节点，dependency节点表示一个依赖（一个坐标）

dependency节点：
    <dependency>
      <groupId>junit</groupId>          //死背
      <artifactId>junit</artifactId>    //死背
      <version>4.11</version>           //死背
      <scope>test</scope>
    </dependency>
    推荐大家使用一个网址去找节点坐标
    https://mvnrepository.com

dependencyManagement节点：
该节点主要是管理所有子项目的依赖节点，而且该节点下只能由
dependencies节点。使用dependencyManagement管理的节点依赖不会导入相应
的依赖，而需要在子项目里面导入相应的依赖，子项目不需要写明版本号。
<dependencyManagement></dependencyManagement>
--------------------------------------------------------------------

2019/11/24  周日
1、Git
1)Git 是一个开源的分布式版本控制系统，用于敏捷高效地处理任何或小或大
    的项目。
2)Git 是 Linus Torvalds 为了帮助管理 Linux 内核开发而开发的
    一个开放源码的版本控制软件。
3)Git 与常用的版本控制工具 CVS, Subversion
    等不同，它采用了分布式版本库的方式，不必服务器端软件支持。

    1)新建一个文件目录：myrepo
    2)鼠标右键bash here 弹出git命令
    3）输入git init命令
    4）使用ssh-keygen -t rsa -C "请在这里输入注册邮箱"，敲打三次回车
       生成密钥文件，位置是（C://User/.ssh文件）
    5）找到生成.ssh文件目录下id_rsa.pub文件用记事本打开，复制所有内容
    6）登陆github官网找到settings,再找到SSH and GPG key菜单，点击
       new SSH key,编写title（任取），粘贴刚刚复制的内容。
    7）认证用户
        git config --global user.email "注册邮箱"
    8）使用git remotr add origin git@链接
    例如：git remotr add origin git@github.com:Huowenjing2019/java-apis.git
    9）将需要上传的文件拷贝到与.git目录同级目录下
   10）在git命令行里面 添加命令将文件添加到缓存
        git add "文件名称"
    11)提交刚刚的添加操作事物
        git commit -m "文件名"
    12）将本地仓库添加的内容上传到云端的github
        git push -u origin master -f

   --------------------------------------------------------------
   2019-11-27  周三
   1、API定义：
    应用程序接口（Application processer interface）
    别人写的代码以类的形式封装，开发者自由调用  不是JDK以坐标调用
一、Object类：所有类都继承object类
   hierarchy.层次  ==等号比的是地址是同一个地址，equals比的是对象内容是否相等
   但是object中的方法是，子类类型赋值给父类引用
   （instanceof通过返回一个布尔值来指出，这个对象
     是否是这个特定类或者是它的子类的一个实例。）
1、等号与equals的区别
2、Tostring():
**:toString()方法就是把对象转换成String类型，转换的算法根据类型和实际需要而定。
    比如一个Integer对象的toString方法就是把这个对象表示的整数转化成字符串，
    133就成了"133"。
**:重写toString 方法的好处：
   可以自定义对象自表示，
二、String类
    1、String是一个不可以改变的字符串类，所有的字符串类都是String类，
      该类被final修饰不能被子类继承,该类提供了大量的APIString对象和操作
      String对象
    2、创建String对象
       **：通过字符串字面量创建字符串对象
           String aa="hello"
       **：通过String的构造器去创建对象

------------------------------------------------------------------
2019-12-4  周三 下午
1、正则表达式
          .表示任意一字符
          \d表示任意一个数字，相当于[0-9]
          \w表示任意一个单词字符，相当于[0-9a-zA-Z_]中任意一个
          \s表示任意一个字符
          \D任意一个数字字符
          \W任意一个非单词字符
          \S任意一个非空白字符

     * 数量词
          X?  表示前面的X出现0次或1次
          X+  表示前面的X出现1次或多次
          X*  表示前面的X出现0次或多次
          X{n}表示前面的X刚好出现n次
          X{n,}表示前面的X至少出现n次
          X{m,n}表示前面的X出现m次到n次之间，包括n

//docer DockerFile面试问题

-------------------------------------------------------------
2019-12-7  周六
                   异常
 1、异常：程序中不正常的退出。
    java语言的异常
    java语言的所有异常的父类是throwable,该类主要由两个直接的子类，分别是：
        Error
        产生的原因主要是硬件原因，内存空间不足、磁盘损坏等
        Exception
        java语言程序运行过程中产生的（程序的逻辑出错，程序运行的内存不足等）
    Exception分为两种：
        **编译时异常
        **运行时异常

     编译时异常：
     编译时异常必须显示抛出给方法的调用者，或许必须使用try...catch异常捕获机制
     运行时异常：
     运行时异常不会出现编译错误，只有在运行时出错的时候会打印
     异常相关信息，运行时一场的父类是RuntimeException，不需要显示
     try...catch机制捕获

  异常的处理机制：
  1、将异常抛出给调用者（调用者指的是方法），通过Throws关键字将异常
    抛出给方法的调用者如：
    public static void mytest1() throws FileNotFoundException {
            InputStream inputStream = new FileInputStream("YHT.txt");
        }该处会出现一个编译时异常，需要处理

  2、将异常使用try..catch机制捕获

            try {
                语句块1;
                语句块2;
                语句块3;
                .......
                语句块n;
                语句块n+1;
            } catch (异常类型1 e) {
                语句块1
            }catch (异常类型2 e) {
                语句块2
            }
            catch (异常类型3 e) {
               语句块3
            }
            catch (异常类型4 e) {
               语句块4
                        }
            catch (异常类型5 e) {
               语句块5
                        }finaly{
              //该处的代码块都会运行，无论是否出错，并且可省略
            }

            总结:程序回一次执行语句块1到语句块n+1，如果执行到某一个语句块
            出现了异常的时候，那么java程序就会到相应的catch块里面去寻找有没有相应
            异常和改异常类型匹配，finall块不管程序是否出现异常都会被执行
            可以关闭某些资源链接

        注意：异常的顺序必须按照从小到大的方式捕获
    手动抛出异常：使用throw关键字
    语法为：throw异常对象。表示手动抛出的异常对象。
 2、运行时异常